<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Starknet Channels for Fiat-Shamir Instantiation</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>

    <!-- syntax highlighting -->
    <script class='remove'>
        async function loadRust() {
            //this is the function you call in 'preProcess', to load the highlighter
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
            const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
            const lang = "language-rust"; // this is the class you use to identify the language
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    const { action: responseAction, lang: responseLang } = data;
                    if (responseAction === action && responseLang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        async function loadPython() {
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/fd9652b0c0d64bfc9f8cae69c72030b1/raw/2315322f87ba81c92c22477a05da6c4181f02df2/respec-py.js"; // URL to Python highlighter
            const propName = "hljsDefinePython"; // Adjust this if needed
            const lang = "language-py";
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    if (data.action === action && data.lang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        var respecConfig = {
            preProcess: [loadRust, loadPython],
            specStatus: "unofficial",
            latestVersion: null,
            license: "cc0",
            editors: [
                {
                    name: "David Wong",
                    url: "https://www.zksecurity.xyz",
                },
            ],
            github: "zksecurity/RFCs",
            shortName: "starknet-channel",
        };
    </script>

</head>

<body>
    <section id="abstract">
        <p>Channels are an abstraction used to mimic the communication channel between the prover and the verifier in a non-interactive protocol. It is useful to ensure that all prover messages are correctly absorbed before being used by the verifier, and that all verifier challenges are correctly produced.</p>
    </section>
    <section id="sotd">
        <p>draft</p>
    </section>
    <section>
<h2>Overview</h2>
<aside class="warning">This specification is work-in-progress.</aside>

<p>A channel is an object that mimics the communication channel between the prover and the verifier, and is used to abstract the <a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat-Shamir transformation</a> used to make the protocol non-interactive.</p>
<p>The Fiat-Shamir transformation works on public-coin protocols, in which the messages of the verifier are pure random values. To work, the Fiat-Shamir transformation replaces the verifier messages with a hash function applied over the transcript up to that point.</p>
<p>A channel is initialized at the beginning of the protocol, and is instantiated with a hash function. It is implemented as a continuous hash that "absorbs" every prover message and which output can be used to produce the verifier's challenges.</p>
</section>
<section>
<h2>Dependencies</h2>
<p>A channel is instantiated with the following two dependencies:</p>
<ul>
<li><code>hades_permutation(s1, s2, s3)</code>. The Hades permutation which permutes a given state of three field elements.</li>
<li><code>poseidon_hash_span(field_elements)</code>. The Poseidon sponge function which hashes a list of field elements.</li>
</ul>
</section>
<section>
<h2>Interface</h2>
<p>A channel has two fields:</p>
<ul>
<li>A <strong><code>digest</code></strong>, which represents the current internal state.</li>
<li>A <strong><code>counter</code></strong>, which helps produce different values when the channel is used repeatedly to sample verifier challenges.</li>
</ul>
<p>The channel has the following interface:</p>
<p><strong>Initialize</strong>. This initializes the channel in the following way: </p>
<ul>
<li>Set the <code>digest</code> to the given <code>digest</code>, which is the prologue/context to the protocol. </li>
<li>Set the <code>counter</code> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn></mrow></math>.</li>
</ul>
<p><strong>Absorb a message from the prover</strong>.</p>
<ul>
<li>Resets the <code>counter</code> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn></mrow></math>.</li>
<li>Set the <code>digest</code> to <code>POSEIDON_hash(digest + 1 || value)</code>.</li>
</ul>
<p>TODO: explain why the +1</p>
<p><strong>Absorb multiple messages from the prover</strong>.</p>
<ul>
<li>Resets the <code>counter</code> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn></mrow></math>.</li>
<li>Set the <code>digest</code> to <code>POSEIDON_hash(digest + 1 || values)</code>.</li>
</ul>
<aside class="warning">This function is not compatible with multiple call to the previous function.</aside>

<p><strong>Produce a verifier challenge</strong>.</p>
<ul>
<li>Produce a random value as <code>hades_permutation(digest, counter, 2)</code>.</li>
<li>Increment the <code>counter</code>.</li>
</ul>
<aside class="warning">With the current design, two different protocols where one produces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>n</mi></mrow></math> challenges and another that produces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>m</mi></mrow></math> challenges will have the same "transcript" and thus will continue to produce the same challenges later on in the protocol. While there are no issues in this design in the context of Starknet, this might not always be secure when used in other protocols.</aside>
</section>
</body>

</html>