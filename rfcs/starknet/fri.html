<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Starknet FRI Verifier</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
     <!-- <script>
      MathJax = {
        tex: {
          inlineMath: [ 
            ['\\(', '\\)'], 
          ],
          displayMath: [ 
            ['\\[', '\\]']
          ],
        }
      };
    </script> 
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> -->

    <!-- syntax highlighting -->
    <script class='remove'>
		async function loadRust() {
			//this is the function you call in 'preProcess', to load the highlighter
			const worker = await new Promise(resolve => {
				require(["core/worker"], ({ worker }) => resolve(worker));
			});
			const action = "highlight-load-lang";
			const langURL =
				"https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
			const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
			const lang = "language-rust"; // this is the class you use to identify the language
			worker.postMessage({ action, langURL, propName, lang });
			return new Promise(resolve => {
				worker.addEventListener("message", function listener({ data }) {
					const { action: responseAction, lang: responseLang } = data;
					if (responseAction === action && responseLang === lang) {
						worker.removeEventListener("message", listener);
						resolve();
					}
				});
			});
		}

        async function loadPython() {
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/fd9652b0c0d64bfc9f8cae69c72030b1/raw/2315322f87ba81c92c22477a05da6c4181f02df2/respec-py.js"; // URL to Python highlighter
            const propName = "hljsDefinePython"; // Adjust this if needed
            const lang = "language-py"; 
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    if (data.action === action && data.lang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

		var respecConfig = {
			preProcess: [loadRust, loadPython],
			specStatus: "base",
			editors: [
				// {% for editor in editors %}
				{
					name: "{{editor.0}}",
					url: "{{editor.1}}",
				},
				// {% endfor %}
			],
			github: "zksecurity/RFCs",
			shortName: "{{short_name}}",
			//			format: "markdown",
		};

              // All config options at https://respec.org/docs/
    //   var respecConfig = {
    //     specStatus: "ED",
    //     editors: [{ name: "David Wong", url: "https://www.zksecurity.xyz" }],
    //     github: "zksecurity/RFCs",
    //     shortName: "dahut",
    //     xref: "web-platform",
    //     group: "my-working-group",
    //   };
	</script>

  </head>
  <body>
    <section id="abstract">
      <p><p>The <strong>Fast Reed-Solomon Interactive Oracle Proofs of Proximity (FRI)</strong> is a cryptographic protocol that allows a prover to prove to a verifier (in an interactive, or non-interactive fashion) that a hash-based commitment (e.g. a Merkle tree) of a vector of values represent the evaluations of a polynomial of some known degree. (That is, the vector committed is not just a bunch of uncorrelated values.) The algorithm is often referred to as a "low degree" test, as the degree of the underlying polynomial is expected to be much lower than the degree of the field the polynomial is defined over. Furthermore, the algorithm can also be used to prove the evaluation of a committed polynomial, an application that is often called FRI-PCS. We discuss both algorithms in this document, as well as how to batch multiple instances of the two algorithms.</p>
<p>For more information about the original construction, see <a href="https://eccc.weizmann.ac.il/report/2017/134/">Fast Reed-Solomon Interactive Oracle Proofs of Proximity</a>. This document is about the specific instantiation of FRI and FRI-PCS as used by the StarkNet protocol.</p>
<aside class="note">Specifically, it matches the [integrity verifier](https://github.com/HerodotusDev/integrity/tree/main/src) which is a Cairo implementation of a Cairo verifier. There might be important differences with the Cairo verifier implemented in C++ or Solidity.</aside></p>
    </section>
    <section id="sotd">
      <p>none</p>
    </section>
    <section>
<h2>Overview</h2>
<p>We briefly give an overview of the FRI protocol, before specifying how it is used in the StarkNet protocol.</p>
<section>
<h3>FRI</h3>
<aside class="note">Note that the protocol implemented closely resembles the high-level explanations of the <a href="https://eprint.iacr.org/2021/582">ethSTARK paper</a>, as such we refer to it in places.</aside>

<p>FRI is a protocol that works by successively reducing the degree of a polynomial, and where the last reduction is a constant polynomial of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn></mrow></math>. Typically the protocol obtains the best runtime complexity when each reduction can halve the degree of its input polynomial. For this reason, FRI is typically described and instantiated on a polynomial of degree a power of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>2</mn></mrow></math>.</p>
<p>If the reductions are "correct", and it takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>n</mi></mrow></math> reductions to produce a constant polynomial in the "last layer", then it is a proof that the original polynomial at "layer 0" was of degree at most <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow></math>.</p>
<p>In order to ensure that the reductions are correct, two mechanisms are used:</p>
<ol>
<li>First, an interactive protocol is performed with a verifier who helps randomizing the halving of polynomials. In each round the prover commits to a "layer" polynomial.</li>
<li>Second, as commitments are not algebraic objects (as FRI works with hash-based commitments), the verifier query them in multiple points to verify that an output polynomial is consistant with its input polynomial and a random challenge. (Intuitively, the more queries, the more secure the protocol.)</li>
</ol>
<section>
<h4>Setup</h4>
<p>To illustrate how FRI works, one can use <a href="https://www.sagemath.org/">sagemath</a> with the following setup:</p>
<pre><code class="language-py"># We use the starknet field (https://docs.starknet.io/architecture-and-concepts/cryptography/p-value/)
starknet_prime = 2^251 + 17*2^192 + 1
starknet_field = GF(starknet_prime)
polynomial_ring.&lt;x&gt; = PolynomialRing(starknet_field)

# find generator of the main group
gen = starknet_field.multiplicative_generator()
assert gen == 3
assert starknet_field(gen)^(starknet_prime-1) == 1 # 3^(order-1) = 1

# lagrange theorem's gives us the orders of all the multiplicative subgroups
# which are the divisors of the main multiplicative group order (which, remember, is p - 1 as 0 is not part of it)
# p - 1 = 2^192 * 5 * 7 * 98714381 * 166848103
multiplicative_subgroup_order = starknet_field.order() - 1
assert list(factor(multiplicative_subgroup_order)) == [(2, 192), (5, 1), (7, 1), (98714381, 1), (166848103, 1)]

# find generator of subgroup of order 2^192
# the starknet field has high 2-adicity, which is useful for FRI and FFTs
# (https://www.cryptologie.net/article/559/whats-two-adicity)
gen2 = gen^( (starknet_prime-1) / (2^192) )
assert gen2^(2^192) == 1

# find generator of a subgroup of order 2^i for i &lt;= 192
def find_gen2(i):
    assert i &gt;= 0
    assert i &lt;= 192
    return gen2^( 2^(192-i) )

assert find_gen2(0)^1 == 1
assert find_gen2(1)^2 == 1
assert find_gen2(2)^4 == 1
assert find_gen2(3)^8 == 1
</code></pre>
</section>
<section>
<h4>Reduction</h4>
<p>A reduction in the FRI protocol is obtained by interpreting an input polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math> as a polynomial of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>2</mn><mi>n</mi></mrow></math> and splitting it into two polynomials <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>g</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi></mrow></math> of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>n</mi></mrow></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mi>g</mi><mo stretchy="false">&#x00028;</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mi>x</mi><mi>h</mi><mo stretchy="false">&#x00028;</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<p>Then, with the help of a verifier's random challenge <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x003B6;</mi></mrow></math>, we can produce a random linear combination of these polynomials to obtain a new polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>g</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mi>&#x003B6;</mi><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>n</mi></mrow></math>:</p>
<pre><code class="language-py">def split_poly(p, remove_square=True):
    assert (p.degree()+1) % 2 == 0
    g = (p + p(-x))/2 # &lt;---------- nice trick!
    h = (p - p(-x))//(2 * x) # &lt;--- nice trick!
    # at this point g and h are still around the same degree of p
    # we need to replace x^2 by x for FRI to (as we want to halve the degrees!)
    if remove_square:
        g = g.parent(g.list()[::2]) # &lt;-- (using python's &lt;!--CODE_BLOCK_0--&gt; syntax)
        h = h.parent(h.list()[::2])
        assert g.degree() == h.degree() == p.degree() // 2
        assert p(7) == g(7^2) + 7 * h(7^2)
    else:
        assert g.degree() == h.degree() == p.degree() - 1
        assert p(7) == g(7) + 7 * h(7)
    return g, h
</code></pre>
<aside class="note">When instantiating the FRI protocol, like in this specification, the verifier is removed using the <a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat-Shamir</a> transformation in order to make the protocol non-interactive.</a></aside>

<p>We can look at the following example to see how a polynomial of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>7</mn></mrow></math> is reduced to a polynomial of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn></mrow></math> in 3 rounds:</p>
<pre><code class="language-py"># p0(x) = 1 + 2x + 3x^2 + 4x^3 + 5x^4 + 6x^5 + 7x^6 + 8x^7
# degree 7 means that we'll get ceil(log2(7)) = 3 rounds (and 4 layers)
p0 = polynomial_ring([1, 2, 3, 4, 5, 6, 7, 8]) 

# round 1: moves from degree 7 to degree 3
h0, g0 = split_poly(p0)
assert h0.degree() == g0.degree() == 3
zeta0 = 3 # &lt;-------------------- the verifier would pick a random zeta
p1 = h0 + zeta0 * g0 # &lt;--------- the prover would send a commitment of p1
assert p0(zeta0) == p1(zeta0^2) # &lt;- sanity check

# round 2: reduces degree 3 to degree 1
h1, g1 = split_poly(p1)
assert g1.degree() == h1.degree() == 1
zeta1 = 12 # &lt;------------ the verifier would pick a random zeta
p2 = h1 + zeta1 * g1 # &lt;-- the prover would send a commitment of p2
assert p1(zeta1) == p2(zeta1^2)
h2, g2 = split_poly(p2)
assert h2.degree() == g2.degree() == 0

# round 3: reduces degree 1 to degree 0
zeta2 = 3920 # &lt;---------- the verifier would pick a random zeta
p3 = h2 + zeta2 * g2 # &lt;-- the prover could send p3 in the clear
assert p2(zeta2) == p3
assert p3.degree() == 0
</code></pre>
</section>
<section>
<h4>Queries</h4>
<p>In the real FRI protocol, each layer's polynomial would be sent using a hash-based commitment (e.g. a Merkle tree of its evaluations over a large domain). As such, the verifier must ensure that each commitment consistently represent the proper reduction of the previous layer's polynomial. To do that, they "query" commitments of the different polynomials of the different layers at points/evaluations. Let's see how this works.</p>
<p>Given a polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>g</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mi>x</mi><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> and two of its evaluations at some points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><mi>v</mi></mrow></math>, we can see that the verifier can recover the two halves by computing:</p>
<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>g</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac></mrow></math></li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>v</mi></mrow></mfrac></mrow></math></li>
</ul>
<p>Then, the verifier can compute the next layer's evaluation at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>v</mi><mn>2</mn></msup></mrow></math> as:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>g</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mn>0</mn></msub><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>

<p>We can see this in our previous example:</p>
<pre><code class="language-py"># first round/reduction
v = 392 # &lt;-------------------------------------- fake sample a point
p0_v, p0_v_neg = p0(v), p0(-v) # &lt;--------------- the 2 queries we need
g0_square = (p0_v + p0_v_neg)/2
h0_square = (p0_v - p0_v_neg)/(2 * v)
assert p0_v == g0_square + v * h0_square # &lt;------ sanity check
</code></pre>
<p>In practice, to check that the evaluation on the next layer's polynomial is correct, the verifier would "query" the prover's commitment to the polynomial. These queries are different from the <strong>FRI queries</strong> (which enforce consistency between layers of reductions), they are <strong>evaluation queries or commitment queries</strong> and result in practice in the prover providing a Merkle membership proof (also called decommitment in this specification) to the committed polynomial.</p>
<p>As we already have an evaluation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>v</mi><mn>2</mn></msup></mrow></math> of the next layer's polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow></math>, we can simply query the evaluation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> to continue the <strong>FRI query</strong> process on the next layer, and so on:</p>
<pre><code class="language-py">p1_v = p1(v^2) # &lt;-------------------------------- query on the next layer
assert g0_square + zeta0 * h0_square == p1_v # &lt;--- the correctness check

# second round/reduction
p1_v_neg = p1(-v^2) # &lt;-- the 1 query we need
g1_square = (p1_v + p1_v_neg)/2 # g1(v^4)
h1_square = (p1_v - p1_v_neg)/(2 * v^2) # h1(v^4)
assert p1_v == g1_square + v^2 * h1_square # p1(v^2) = g1(v^4) + v^2 * h1(v^4)
p2_v = p2(v^4) # &lt;-- query the next layer
assert p2(v^4) == g1_square + zeta1 * h1_square # p2(v^4) = g1(v^4) + zeta1 * h1(v^4)

# third round/reduction
p2_v_neg = p2(-v^4) # &lt;-- the 1 query we need
g2_square = (p2_v + p2_v_neg)/2 # g2(v^8)
h2_square = (p2_v - p2_v_neg)/(2 * v^4) # h2(v^8)
assert p2_v == g2_square + v^4 * h2_square # p2(v^4) = g2(v^8) + v^4 * h2(v^8)
assert p3 == g2_square + zeta2 * h2_square # we already received p3 at the end of the protocol
</code></pre>
</section>
<section>
<h4>Skipping FRI layers</h4>
<p>Section 3.11.1 "Skipping FRI Layers" of the ethSTARK paper describes an optimization which skips some of the layers/rounds. The intuition is the following: if we removed the first round commitment (to the polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow></math>), then the verifier would not be able to:</p>
<ul>
<li>query <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> to verify that layer</li>
<li>query <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi><mn>1</mn><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> to continue the protocol and get <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>&#x0002C;</mo><msub><mi>h</mi><mn>1</mn></msub></mrow></math></li>
</ul>
<p>The first point is fine, as there's nothing to check the correctness of. To address the second point, we can use the same technique we use to compute <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi><mn>1</mn><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>. Remember, we needed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow></math> to compute <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>g</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>.
But to compute <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>g</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>, we need the quadratic residues of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup></mrow></math>, that is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>w</mi></mrow></math>, such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>w</mi><mn>2</mn></msup><mo>&#x0003D;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup></mrow></math>,
so that we can compute <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>g</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>w</mi><mo stretchy="false">&#x00029;</mo></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>w</mi><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<p>We can easily compute them by using <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x003C4;</mi></mrow></math> (<code>tau</code>), the generator of the subgroup of order <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>4</mn></mrow></math>:</p>
<pre><code class="language-py">tau = find_gen2(2)
assert tau.multiplicative_order() == 4

# so now we can compute the two roots of -v^2 as
assert (tau * v)^2 == -v^2
assert (tau^3 * v)^2 == -v^2

# and when we query p2(v^4) we can verify that it is correct
# if given the evaluations of p0 at v, -v, tau*v, tau^3*v
p0_tau_v = p0(tau * v)
p0_tau3_v = p0(tau^3 * v)
p1_v_square = (p0_v + p0_v_neg)/2 + zeta0 * (p0_v - p0_v_neg)/(2 * v)
p1_neg_v_square = (p0_tau_v + p0_tau3_v)/2 + zeta0 * (p0_tau_v - p0_tau3_v)/(2 * tau * v)
assert p2(v^4) == (p1_v_square + p1_neg_v_square)/2 + zeta1 * (p1_v_square - p1_neg_v_square)/(2 * v^2)
</code></pre>
<aside class="note">There is no point producing a new challenge `zeta1` as nothing more was observed from the verifier's point of view during the skipped round. As such, FRI implementations will usually use `zeta0^2` as "folding factor" (and so on if more foldings occur).</aside>

</section>
<section>
<h4>Last Layer Optimization</h4>
<p>Section 3.11.2 "FRI Last Layer" of the ethSTARK paper describes an optimization which stops at an earlier round. We show this here by removing the last round.</p>
<p>At the end of the second round we imagine that the verifier receives the coefficients of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow></math> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>g</mi><mn>2</mn></msub></mrow></math>) directly:</p>
<pre><code class="language-py">p2_v = h2 + v^4 * g2 # they can then compute p2(v^4) directly
assert g1_square + zeta1 * h1_square == p2_v # and then check correctness
</code></pre>
</section>
<section>
<h4>Commitments</h4>
<p>Commitments used in this specification are Merkle tree commitments of evaluations of a polynomial. In other words, the leaves of the Merkle tree are evaluations of a polynomial at distinct points.</p>
<p>We use a coset to evaluate the polynomial at the different points. This is for two reasons:</p>
<ol>
<li>In FRI we can increase the size of the evaluated domain in the commitments, in order to decrease the number of queries needed to ensure high bit-security. (TODO: how do cosets help us here?)</li>
<li>As used in Starknet STARK (TODO: link to the STARK verifier specification), the layer 0 polynomial has to be computed as a rational polynomial that would lead to division by zero issues if evaluated in the original evaluation domain. As such we take a coset to avoid this issue.</li>
</ol>
<p>As with what we specify in the rest of this document, we produce a coset of the same size as the evaluation domain (the domain which is used to produce the layer 0 polynomial in the Starknet STARK protocol).</p>
<pre><code class="language-py"># if we evaluate the polynomial on a set of size 8 (so the blowup factor is 1)
g = find_gen2(log(8,2))

coset = [3 * g^i for i in range(8)] 
poly8_evals = [p0(x) for x in coset] # &lt;-- we would merklelify this as statement
</code></pre>
</section>
</section>
<section>
<h3>FRI-PCS</h3>
<p>Given a polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi></mrow></math> and an evaluation point <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>a</mi></mrow></math>, a prover who wants to prove that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>a</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mi>b</mi></mrow></math> can prove the related statement for some quotient polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>q</mi></mrow></math> of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mo stretchy="false">&#x00028;</mo><mi>f</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><mn>1</mn></mrow></math>:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfrac><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><mi>b</mi></mrow><mrow><mi>x</mi><mo>&#x02212;</mo><mi>a</mi></mrow></mfrac><mo>&#x0003D;</mo><mi>q</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math>

<p>(This is because if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>a</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mi>b</mi></mrow></math> then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>a</mi></mrow></math> should be a root of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><mi>b</mi></mrow></math> and thus the polynomial can be factored in this way.)</p>
<p>Specifically, FRI-PCS proves that they can produce such a (commitment to a) polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>q</mi></mrow></math>.</p>
</section>
<section>
<h3>Aggregating multiple FRI proofs</h3>
<p>To prove that two polynomials <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>a</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>b</mi></mrow></math> exist and are of degree at most <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi></mrow></math>, a prove simply prove that a random linear combination of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>a</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>b</mi></mrow></math> exists and is of degree at most <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi></mrow></math>.</p>
<p>TODO: what if the different polynomials are of different degrees?</p>
</section>
</section>
<section>
<h2>Notable differences with vanilla FRI</h2>
<p>Besides obvious missing implementation details from the description above, the protocol is pretty much instantiated as is, except for a few changes to the folding and querying process.</p>
<p>As explained above, in the "vanilla FRI" protocol the verifier gets evaluations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow></math> and computes the next layer's evaluation at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>v</mi><mn>2</mn></msup></mrow></math> as</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mrow><mi>i</mi></mrow></msub><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>v</mi></mrow></mfrac></mrow></math>

<p>which is equivalent to</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>g</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mrow><mi>i</mi></mrow></msub><msub><mi>h</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>

<p>where </p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>g</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mi>x</mi><msub><mi>h</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>

<p>The first difference in this specification is that, assuming no skipped layers, the folded polynomial is multiplied by 2:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mn>2</mn><mo stretchy="false">&#x00028;</mo><msub><mi>g</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mrow><mi>i</mi></mrow></msub><mi>&#x000B7;</mi><msup><mn>3</mn><mrow><mo>&#x02212;</mo><mn>1</mn></mrow></msup><mi>&#x000B7;</mi><msub><mi>h</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>

<p>This means that the verifier has to modify their queries slightly by not dividing by 2:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mrow><mi>i</mi></mrow></msub><mi>g</mi><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mi>v</mi></mrow></mfrac></mrow></math>

<p>The second difference is that while the evaluations of the first layer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow></math> happen in a coset, further evaluations happen in the original (blown up) evaluation domain (which is avoided for the first polynomial as it might lead to divisions by zero with the polynomials used in the Starknet STARK protocol). To do this, the prover defines the first reduced polynomial as:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mn>2</mn><mo stretchy="false">&#x00028;</mo><msub><mi>g</mi><mrow><mn>0</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mn>9</mn><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mn>0</mn></msub><mfrac><mrow><msub><mi>h</mi><mrow><mn>0</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mn>9</mn><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mi>x</mi></mrow></mfrac><mo stretchy="false">&#x00029;</mo></mrow></math>

<p>Notice that the prover has also divided by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>x</mi></mrow></math> instead of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>3</mn><mi>x</mi></mrow></math>. This is a minor change that helps with how the verifier code is structured.</p>
<p>This means that the verifier computes the queries on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>1</mn></msub><mrow><mi>x</mi></mrow></mrow></math> at points on the original subgroup. So the queries of the first layer are produced using <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>v</mi><mi>&#x02032;</mi></msup><mo>&#x0003D;</mo><mi>v</mi><mo>&#x0002F;</mo><mn>3</mn></mrow></math> (assuming no skipped layers).</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mrow><mi>&#x02032;</mi><mn>2</mn></mrow></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mn>0</mn></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><msup><mi>v</mi><mi>&#x02032;</mi></msup></mrow></mfrac></mrow></math>

<aside class="note">we assume no skipped layers, which is always the case in this specification for the first layer's reduction.</aside>

<p>After that, everything happens as normal (except that now the prover uses the original evaluation domain instead of a coset to evaluate and commit to the layer polynomials).</p>
<p>Note that these changes can easily be generalized to work when layers are skipped.</p>
</section>
<section>
<h2>Dependencies</h2>
<p>In this section we list all dependencies and the API this standard relies on.</p>
<section>
<h3>Hash Functions</h3>
<p>We rely on two type of hash functions:</p>
<ul>
<li>A circuit-friendly hash. Specifically, <strong>Poseidon</strong>.</li>
<li>A standard hash function. Specifically, <strong>Keccak</strong>.</li>
</ul>
<p>TODO: why the alternate use of hash functions?</p>
</section>
<section>
<h3>Evaluation of the first FRI layer</h3>
<p>As part of the protocol, the prover must provide a number of evaluations of the first layer polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow></math>. This is abstracted in this specification as the function <code>eval_oods_polynomial</code> which acts as an oracle from FRI's perspective.</p>
<p>TODO: not a very satisfying explanation</p>
<p>Note that this function is not fixed here, as the polynomial being "tested" could be computed in different ways. See the <a href="stark.html">Starknet STARK verifier specification</a> for a concrete example (and for an explanation of why the function is named this way).</p>
</section>
</section>
<section>
<h2>Constants</h2>
<p>We use the following constants throughout the protocol.</p>
<section>
<h3>Protocol constants</h3>
<p><strong><code>STARKNET_PRIME = 3618502788666131213697322783095070105623107215331596699973092056135872020481</code></strong>. The Starknet prime (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><mn>251</mn></mrow></msup><mo>&#x0002B;</mo><mn>17</mn><mi>&#x000B7;</mi><msup><mn>2</mn><mrow><mn>192</mn></mrow></msup><mo>&#x0002B;</mo><mn>1</mn></mrow></math>).</p>
<p><strong><code>FIELD_GENERATOR = 3</code></strong>. The generator for the main multiplicative subgroup of the Starknet field. This is also used as coset factor to produce the coset used in the first layer's evaluation.</p>
</section>
<section>
<h3>FRI constants</h3>
<p><strong><code>MAX_LAST_LAYER_LOG_DEGREE_BOUND = 15</code></strong>. TKTK</p>
<p><strong><code>MAX_FRI_LAYERS = 15</code></strong>. The maximum number of layers in the FRI protocol. This means that the protocol can test that committed polynomials exist and are of degree at most <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><mn>15</mn></mrow></msup></mrow></math>. (TODO: double check)</p>
<p><strong><code>MAX_FRI_STEP = 4</code></strong>. The maximum number of layers that can be skipped in FRI (see the overview for more details).</p>
<p><strong><code>MONTGOMERY_R = 3618502788666127798953978732740734578953660990361066340291730267701097005025</code></strong>. The Montgomery form of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup><mspace width="1em" /><mi>mod</mi><mspace width="0.333em" /><mtext>STARK_PRIME</mtext></mrow></math>:</p>
</section>
<section>
<h3>TODO: Step generators</h3>
<ul>
<li>we are in a coset, so a fixed value <code>g=3</code> is chosen</li>
<li>we also must understand how to compute the skipped layers, that is what are the elements of the subgroups of order <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>&#x0002C;</mo><mn>2</mn><mo>&#x0002C;</mo><mn>3</mn><mo>&#x0002C;</mo><mn>4</mn><mo stretchy="false">]</mo></mrow></math> used by the prover and what are their corresponding inverses.</li>
</ul>
<p>These are used to skip layers during the FRI protocol. Only 1, 2, 3, or 4 layers can be skipped, each associated to one of the constant below (except for skipping a single layer which is trivial):</p>
<pre><code class="language-rust">// to skip 4 layers
const OMEGA_16: felt252 = 0x5c3ed0c6f6ac6dd647c9ba3e4721c1eb14011ea3d174c52d7981c5b8145aa75;
// to skip 3 layers
const OMEGA_8: felt252 = 0x446ed3ce295dda2b5ea677394813e6eab8bfbc55397aacac8e6df6f4bc9ca34;
// to skip 2 layers
const OMEGA_4: felt252 = 0x1dafdc6d65d66b5accedf99bcd607383ad971a9537cdf25d59e99d90becc81e;
</code></pre>
<p>TODO: explain more here</p>
</section>
</section>
<section>
<h2>Configuration</h2>
<section>
<h3>General configuration</h3>
<p>The FRI protocol is globally parameterized according to the following variables which from the protocol making use of FRI. For a real-world example, check the <a href="stark.md">Starknet STARK verifier specification</a>.</p>
<p><strong><code>n_verifier_friendly_commitment_layers</code></strong>. The number of layers (starting from the bottom) that make use of the circuit-friendly hash.</p>
<p><strong><code>proof_of_work_n_bits</code></strong>. The number of bits required for the proof of work. This value should be between 20 and 50.</p>
</section>
<section>
<h3>Commitment configuration</h3>
<p>The protocol as implemented accepts proofs created using different parameters. This allows provers to decide on the trade-offs between proof size, prover time and space complexity, and verifier time and space complexity. </p>
<p>A FRI layer reduction can be configured with the following fields:</p>
<p><strong><code>table_n_columns</code></strong>. The number of values committed in each leaf of the Merkle tree. As explained in the overview, each FRI reduction makes predictible related queries to each layer, as such related points are grouped together to reduce multiple related queries to a single one.</p>
<p><strong><code>vector_height</code></strong>. The height of the Merkle tree. See the FRI config below to understand how this is validated. (TODO: why do we carry this if we already know the domain size there?)</p>
<p><strong><code>vector_n_verifier_friendly_commitment_layers</code></strong>. The number of layers (starting from the bottom) that use a circuit-friendly hash (TODO: double check). (TODO: remove this level of detail? maybe not if this has to match the proof format)</p>
<pre><code class="language-rust">struct VectorCommitmentConfig {
    height: felt252,
    n_verifier_friendly_commitment_layers: felt252,
}

struct TableCommitmentConfig {
    n_columns: felt252,
    vector: VectorCommitmentConfig,
}
</code></pre>
</section>
<section>
<h3>FRI configuration</h3>
<p>A FRI configuration contains the following fields:</p>
<p><strong><code>log_input_size</code></strong>. The size of the input layer to FRI (the number of evaluations committed). (TODO: double check)</p>
<p><strong><code>n_layers</code></strong>. The number of layers or folding that will occur as part of the FRI proof.</p>
<p><strong><code>inner_layers</code></strong>. The configuration for each of the layers (minus the first layer).</p>
<p><strong><code>fri_step_sizes</code></strong>. The number of layers to skip for each folding/reduction of the protocol.</p>
<p><strong><code>log_last_layer_degree_bound</code></strong>. The degree of the last layer's polynomial. As it is sent in clear as part of the FRI protocol, this value represents the (log) number of coefficients (minus 1) that the proof will contain.</p>
<pre><code class="language-rust">struct FriConfig {
    log_input_size: felt252,
    n_layers: felt252,
    inner_layers: Span&lt;TableCommitmentConfig&gt;,
    fri_step_sizes: Span&lt;felt252&gt;,
    log_last_layer_degree_bound: felt252,
}
</code></pre>
<p>TODO: validate(cfg, log_n_cosets, n_verified_friendly_commitment_layers):</p>
<ul>
<li>the number of layers <code>n_layers</code> must be within the range <code>[2, MAX_FRI_LAYERS]</code> (see constants)</li>
<li>the <code>log_last_layer_degree_bound</code> must be less or equal to <code>MAX_LAST_LAYER_LOG_DEGREE_BOUND</code></li>
<li>the first<code>fri_step_sizes[0]</code> must be 0</li>
<li>for every <code>fri_step_sizes[i]</code> check:</li>
<li>that the step <code>fri_step_sizes[i]</code> is within the range <code>[1, MAX_FRI_STEP]</code></li>
<li>that the previous layer table commitment configuration <code>inner_Layers[i-1]</code> has<ul>
<li>a number of columns <code>n_columns = 2^fri_step</code> (TODO: why?)</li>
<li>a valid configuration, which can be verified using the expected log input size and the <code>n_verifier_friendly_commitment_layers</code></li>
<li>expected log input size should be the input size minus all the step sizes so far</li>
</ul>
</li>
<li>the <code>log_expected_input_degree + log_n_cosets == log_input_size</code></li>
<li>TODO: why is log_n_cosets passed? and what is it? (number of additional cosets with the blowup factor?)</li>
<li>where <code>log_expected_input_degree = sum_of_step_sizes + log_last_layer_degree_bound</code></li>
</ul>
</section>
</section>
<section>
<h2>Commitments</h2>
<p>Commitments of polynomials are done using <a href="">Merkle trees</a>. The Merkle trees can be configured to hash some parameterized number of the lower layers using a circuit-friendly hash function (Poseidon).</p>
<ul>
<li>TODO: why montgomery form?</li>
</ul>
<section>
<h3>Table commitments</h3>
<p>A table commitment in this context is a vector commitment where leaves are potentially hashes of several values (tables of multiple columns and a single row).</p>
</section>
<section>
<h3>Vector commitments</h3>
<p>A vector commitment is simply a Merkle tree. </p>
<p>TODO: diagram.</p>
<p><img alt="vector commit" src="/img/starknet/fri/vector_commit.png" /></p>
</section>
<section>
<h3>Vector membership proofs</h3>
<p>A vector decommitment/membership proof must provide a witness (the neighbor nodes missing to compute the root of the Merkle tree) ordered in a specific way. The following algorithm dictates in which order the nodes hash values provided in the proof are consumed:</p>
<p><img alt="vector decommit" src="/img/starknet/fri/vector_decommit.png" /></p>
</section>
<section>
<h3>Note on commitment multiple evaluations under the same leaf</h3>
<ul>
<li>the following array contains all the 16-th roots of unity, handily ordered</li>
<li>that is, the first represents the subgroup of order 1, the two first values represent the subgroup of order 2, the four first values represent the subgroup of order 4, and so on</li>
<li>furthermore, these values are chosen in relation to how evaluations are ordered in a leaf of a commitment</li>
<li>each value tells you exactly what to multiply to 1/(something*x) to obtain 1/(x)</li>
<li>TODO: but wait, how is inv_x obtained... that doesn't make sense no?</li>
<li>it seems like the following values are used to "correct" the x value depending on where x pointed at</li>
</ul>
<pre><code>array![
    0x1,
    0x800000000000011000000000000000000000000000000000000000000000000,
    0x625023929a2995b533120664329f8c7c5268e56ac8320da2a616626f41337e3,
    0x1dafdc6d65d66b5accedf99bcd607383ad971a9537cdf25d59e99d90becc81e,
    0x63365fe0de874d9c90adb1e2f9c676e98c62155e4412e873ada5e1dee6feebb,
    0x1cc9a01f2178b3736f524e1d06398916739deaa1bbed178c525a1e211901146,
    0x3b912c31d6a226e4a15988c6b7ec1915474043aac68553537192090b43635cd,
    0x446ed3ce295dda2b5ea677394813e6eab8bfbc55397aacac8e6df6f4bc9ca34,
    0x5ec467b88826aba4537602d514425f3b0bdf467bbf302458337c45f6021e539,
    0x213b984777d9556bac89fd2aebbda0c4f420b98440cfdba7cc83ba09fde1ac8,
    0x5ce3fa16c35cb4da537753675ca3276ead24059dddea2ca47c36587e5a538d1,
    0x231c05e93ca34c35ac88ac98a35cd89152dbfa622215d35b83c9a781a5ac730,
    0x00b54759e8c46e1258dc80f091e6f3be387888015452ce5f0ca09ce9e571f52,
    0x7f4ab8a6173b92fda7237f0f6e190c41c78777feabad31a0f35f63161a8e0af,
    0x23c12f3909539339b83645c1b8de3e14ebfee15c2e8b3ad2867e3a47eba558c,
    0x5c3ed0c6f6ac6dd647c9ba3e4721c1eb14011ea3d174c52d7981c5b8145aa75,
]
</code></pre>
<ul>
<li>that is, if x pointed at the beginning of a coset, then we don't need to correct it (the first evaluation committed to contains x)</li>
<li>but if x pointed at the first value, it actually points to an evaluation of -x, so we need to correct the -x we have by multiplying with -1 again so that we get x (or -1/x becomes 1/x, same thing)</li>
<li>if x points to the 2 value, then </li>
</ul>
</section>
</section>
<section>
<h2>Channel</h2>
<p>we should specify this primitive</p>
</section>
<section>
<h2>Protocol</h2>
<p>The FRI protocol is split into two phases:</p>
<ol>
<li>Commit phase</li>
<li>Query phase</li>
</ol>
<section>
<h3>Commit Phase</h3>
<p>This should basically just absorb the commitments of every layer sent by the prover (potentially skipping layers)</p>
<pre><code class="language-rust">#[derive(Drop, Copy, PartialEq, Serde)]
struct TableCommitmentConfig {
    n_columns: felt252, // TODO: gets divided by 2 at every step in FRI?
    vector: VectorCommitmentConfig,
}
struct VectorCommitmentConfig {
    height: felt252, // TODO: ?
    n_verifier_friendly_commitment_layers: felt252, // TODO: ?
}
</code></pre>
<p>The layer 0 polynomial is not part of the protocol, we assume that it comes from somewhere and that we can query evaluations of it in a coset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>3</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mi>e</mi></msub></mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mi>e</mi></msub></mrow></math> is the generator of the evaluation domain. In the <a href="stark.html">Starknet STARK protocol</a> it represents a blown up evaluation domain, that is, an evaluation domain that is a larger power of 2 than the evaluation domain used in the protocol.</p>
<pre><code class="language-py"># TODO: step_sizes is ignored! Shouldn't we check that the layer cfg are properly following the step sizes?
def fri_commit_rounds(channel, n_layers, configs, unsent_commitments, step_sizes):
    commitments = []
    eval_points = []
    # TODO: we don't check that n_layers matches the length of these arrays!
    for unsent_commitment, cfg in zip(unsent_commitments, configs):
        commit = table_commit(channel, unsent_commitment, cfg) # absorbs the commitment # TODO: where is each cfg checked?
        commitments.append(commit)
        eval_points.append(channel.random_felt_to_prover())

def fri_commit(channel, unsent_commitment, cfg):
    assert cfg.fri_step_sizes[0] == 0

    # why n_layers - 1 ?
    commitments, eval_points = fri_commit_rounds(channel, cfg.n_layers-1, cfg.inner_layers, unsent_commitment.inner_layers, cfg.fri_step_sizes)

    # absorb last layer
    channel.read_felt_vector_from_prover(unsent_commitment.last_layer_coefficients)

    # check that the last layer matches the config
    assert pow(2, cfg.log_last_layer_degree_bound) == len(unsent_commitment.last_layer_coefficients)

    return FriCommitment(cfg, inner_layers=commitments, eval_points, last_layer_coefficients=unsent_commitment.last_layer_coefficients)
</code></pre>
<p>The first round has a step size of 1, every other round has a step in <code>[1, MAX_FRI_STEP=4]</code>.</p>
<p>TODO: explain why, I think this is because you don't want to have to produce too many evaluations for the first layer (which is  expensive in the <a href="stark.html">STARK protocol</a>).</p>
</section>
<section>
<h3>Query Phase</h3>
<p>FRI queries are generated once, and then refined through each reduction of the FRI protocol. The number of queries that is randomly generated is based on <a href="">configuration</a>.</p>
<p>Each FRI query is composed of the following fields:</p>
<ul>
<li><code>index</code>: the index of the query in the layer's evaluations. Note that this value needs to be shifted before being used as a path in a Merkle tree commitment.</li>
<li><code>y_value</code>: the evaluation of the layer's polynomial at the queried point.</li>
<li><code>x_inv_value</code>: the inverse of the point at which the layer's polynomial is evaluated. This value is derived from the <code>index</code> as explained in the next subsection.</li>
</ul>
<p>That is, we should have for each FRI query for the layer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></math> the following identity:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo>&#x0002F;</mo><mtext>x_inv_value</mtext><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mtext>y_value</mtext></mrow></math>

<p>Or in terms of commitment, that the decommitment at path the path behind <code>index</code> is <code>y_value</code>.</p>
<aside class="note">This is not exactly correct. The Commitment section explains that index points to a point, whereas we need to point to the path in the Merkle tree commitment that gathers its associated points.

#### Generating queries

The generation of each FRI query goes through the same process:

* Sample a random challenge from the [channel]().
* Truncate the challenge to obtain the lower 128-bit chunk.
* Reduce it modulo the size of the evaluation domain.

Finally, when all FRI queries have been generated, they are sorted in ascending order.

TODO: this is important due to the decommit algorithm.

#### Verify a layer's queries

TODO: refer to the section on the first layer evaluation stuff (external dependency)

Besides the first and last layers, each layer verification of a query happens by simply decommiting a layer's queries.


<pre><code class="language-rust">table_decommit(
        commitment,
        verify_indices.span(),
        TableDecommitment { values: verify_y_values.span() },
        layer_witness.table_witness,
        settings,
    );
</code></pre>


TODO: link to section on merkle tree

#### Computing the next layer's queries

Each reduction will produce queries to the next layer, which will expect specific evaluations.

The next queries are derived as:

* index: index / coset_size
* point: point^2
* value: FRI formula below

##### FRI formula

The next evaluations expected at the queried layers are derived as:

Queries between layers verify that the next layer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mi>j</mi></mrow></msub></mrow></math> is computed correctly based on the currently layer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub></mrow></math>.
The next layer is either the direct next layer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub></mrow></math> or a layer further away if the configuration allows layers to be skipped.
Specifically, each reduction is allowed to skip 0, 1, 2, or 3 layers (see the `MAX_FRI_STEP` constant).

TODO: why MAX_FRI_STEP=3?

no skipping:

* given a layer evaluations at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x000B1;</mi><mi>v</mi></mrow></math>, a query without skipping layers work this way:
* we can compute the next layer's *expected* evaluation at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>v</mi><mn>2</mn></msup></mrow></math> by computing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>v</mi></mrow></mfrac></mrow></math>
* we can then ask the prover to open the next layer's polynomial at that point and verify that it matches

1 skipping with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>4</mn></msub></mrow></math> the generator of the 4-th roots of unity (such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mn>4</mn><mn>2</mn></msubsup><mo>&#x0003D;</mo><mo>&#x02212;</mo><mn>1</mn></mrow></math>):

* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>&#x000B7;</mi><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>

as you can see, this requires 4 evaluations of p_{i} at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi></mrow></math>.

2 skippings with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>8</mn></msub></mrow></math> the generator of the 8-th roots of unity (such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>2</mn></msubsup><mo>&#x0003D;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>4</mn></msubsup><mo>&#x0003D;</mo><mo>&#x02212;</mo><mn>1</mn></mrow></math>):

* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>&#x000B7;</mi><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>&#x000B7;</mi><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>4</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msup><mi>v</mi><mn>4</mn></msup></mrow></mfrac></mrow></math>

as you can see, this requires 8 evaluations of p_{i} at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi></mrow></math>.

3 skippings with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mrow><mn>16</mn></mrow></msub></mrow></math> the generator of the 16-th roots of unity (such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mrow><mn>16</mn></mrow><mn>2</mn></msubsup><mo>&#x0003D;</mo><msub><mi>&#x003C9;</mi><mrow><mn>8</mn></mrow></msub></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mrow><mn>16</mn></mrow><mn>4</mn></msubsup><mo>&#x0003D;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub></mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mrow><mn>16</mn></mrow><mn>8</mn></msubsup><mo>&#x0003D;</mo><mo>&#x02212;</mo><mn>1</mn></mrow></math>):

* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>&#x000B7;</mi><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>&#x000B7;</mi><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>7</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>7</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msub><mi>&#x003B6;</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>7</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>7</mn></msup><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>7</mn></msup><mi>v</mi></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>&#x000B7;</mi><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>2</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><msup><mi>v</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>4</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msup><mi>v</mi><mn>4</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>4</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>2</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msub><mi>&#x003C9;</mi><mn>4</mn></msub><msup><mi>v</mi><mn>4</mn></msup></mrow></mfrac></mrow></math>
* <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>4</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>1</mn></msup><mn>6</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x0002B;</mo><msubsup><mi>&#x003B6;</mi><mi>i</mi><mn>8</mn></msubsup><mi>&#x000B7;</mi><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>3</mn></mrow></msub><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><msup><mi>v</mi><mn>8</mn></msup><mo stretchy="false">&#x00029;</mo></mrow><mrow><mn>2</mn><mi>&#x000B7;</mi><msup><mi>v</mi><mn>8</mn></msup></mrow></mfrac></mrow></math>

as you can see, this requires 16 evaluations of p_{i} at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>4</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>8</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msubsup><mi>&#x003C9;</mi><mn>8</mn><mn>3</mn></msubsup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><mn>6</mn><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>3</mn></msup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>1</mn></msub><msup><mn>6</mn><mn>5</mn></msup><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mn>7</mn></msub><mi>v</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>&#x003C9;</mi><mn>7</mn></msub><mi>v</mi></mrow></math>.

TODO: reconcile with section on the differences with vanilla FRI

TODO: reconcile with constants used for elements and inverses chosen in subgroups of order <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow></math> (the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x003C9;</mi></mrow></math>s)

### Proof of work

In order to increase the cost of attacks on the protocol, a proof of work is added at the end of the commitment phase.

Given a 32-bit hash `digest` and a difficulty target of `n_bits`, verify the 64-bit proof of work `nonce` by doing the following:

1. Produce a `init_hash = hash_n_bytes(0x0123456789abcded || digest || n_bits)` (TODO: endianness)
1. Produce a `hash = hash_n_bytes(init_hash || nonce)` (TODO: endianness)
1. Enforce that the 128-bit high bits of `hash` start with `128 - n_bits` zeros. (TODO: where is `n_bits` enforced to not be more than 128? I can't remember)


<pre><code class="language-rust">fn proof_of_work_commit(
    ref channel: Channel, unsent_commitment: ProofOfWorkUnsentCommitment, config: ProofOfWorkConfig
) {
    verify_proof_of_work(channel.digest.into(), config.n_bits, unsent_commitment.nonce);
    channel.read_uint64_from_prover(unsent_commitment.nonce);
}

fn verify_proof_of_work(digest: u256, n_bits: u8, nonce: u64) {
    // Compute the initial hash.
    // Hash(0x0123456789abcded || digest   || n_bits )
    //      8 bytes            || 32 bytes || 1 byte
    // Total of 0x29 = 41 bytes.

    let mut init_hash_data = ArrayTrait::new(); // u8 with blake, u64 with keccak
    init_hash_data.append_big_endian(MAGIC);
    init_hash_data.append_big_endian(digest);
    let init_hash = hash_n_bytes(init_hash_data, n_bits.into(), true).flip_endianness();

    // Compute Hash(init_hash || nonce   )
    //              32 bytes  || 8 bytes
    // Total of 0x28 = 40 bytes.

    let mut hash_data = ArrayTrait::new(); // u8 with blake, u64 with keccak
    hash_data.append_big_endian(init_hash);
    hash_data.append_big_endian(nonce);
    let hash = hash_n_bytes(hash_data, 0, false).flip_endianness();

    let work_limit = pow(2, 128 - n_bits.into());
    assert(
        Into::&lt;u128, u256&gt;::into(hash.high) &lt; Into::&lt;felt252, u256&gt;::into(work_limit),
        'proof of work failed'
    )
}
</code></pre>


### Full Protocol

The FRI flow is split into four main functions. The only reason for doing this is that verification of FRI proofs can be computationally intensive, and users of this specification might want to split the verification of a FRI proof in multiple calls.

The four main functions are:

1. `fri_commit`, which returns the commitment to every layers of the FRI proof.
1. `fri_verify_initial`, which returns the initial set of queries.
1. `fri_verify_step`, which takes a set of queries and returns another set of queries.
1. `fri_verify_final`, which takes the final set of queries and the last layer coefficients and returns the final result.

To retain context, functions pass around two objects:


<pre><code class="language-rust">struct FriVerificationStateConstant {
    // the number of layers in the FRI proof (including skipped layers) (TODO: not the first)
    n_layers: u32, 
    // commitments to each layer (excluding the first, last, and any skipped layers)
    commitment: Span&lt;TableCommitment&gt;, 
    // verifier challenges used to produce each (non-skipped) layer polynomial (except the first)
    eval_points: Span&lt;felt252&gt;, 
    // the number of layers to skip for each reduction
    step_sizes: Span&lt;felt252&gt;, 
    // the hash of the polynomial of the last layer
    last_layer_coefficients_hash: felt252, 
}
struct FriVerificationStateVariable {
    // a counter representing the current layer being verified
    iter: u32, 
    // the FRI queries for each (non-skipped) layer
    queries: Span&lt;FriLayerQuery&gt;, 
}
</code></pre>


<aside note="warning">It is the responsibility of the wrapping protocol to ensure that these three functions are called sequentially, enough times, and with inputs that match the output of previous calls.</aside>

We give more detail to each function below.

**`fri_commit`

1. Initialize the channel with a prologue. A prologue contains any context relevant to this proof.
1. stark_commit(channel, public_input, unsent_commitment, cfg, stark_domains)
1. last_layer_coefficients = stark_commitment.fri.last_layer_coefficients
1. generate_queries(channel, config.n_queries, stark_domains.eval_domain_size)
1. stark_verify(NUM_COLUMNS_FIRST, NUM_COLUMNS_SECOND, queries, stark_Comitment, witness, stark_domains, settings)

TODO: where is settings used?

**`fri_verify_initial(queries, fri_commitment, decommitment)`**.

* enforce that the number of queries matches the number of values to decommit
* enforce that last layer has the right number of coefficients (TODO: how?)
* compute the first layer of queries `gather_first_layer_queries` (TODO: how?) <-- this only happens for the first layer
* initialize and return the two state objects


<pre><code class="language-rust">    (
        FriVerificationStateConstant {
            n_layers: (commitment.config.n_layers - 1).try_into().unwrap(),
            commitment: commitment.inner_layers,
            eval_points: commitment.eval_points,
            step_sizes: commitment
                .config
                .fri_step_sizes
                .slice(1, commitment.config.fri_step_sizes.len() - 1),
            last_layer_coefficients_hash: hash_array(commitment.last_layer_coefficients),
        },
        FriVerificationStateVariable { iter: 0, queries: fri_queries.span(), }
    )
}
</code></pre>


**`fri_verify_step(stateConstant, stateVariable, witness, settings)`**.

* enforce that `stateVariable.iter <= stateConstant.n_layers`
* compute the next layer queries (TODO: link to section on that)
* verify the queries
* increment the `iter` counter
* return the next queries and the counter

**`fri_verify_final(stateConstant, stateVariable, last_layer_coefficients)`**.

* enforce that the counter has reached the last layer from the constants (`iter == n_layers`)
* enforce that the last_layer_coefficient matches the hash contained in the state (TODO: only relevant if we created that hash in the first function)
* manually evaluate the last layer's polynomial at every query and check that it matches the expected evaluations.


<pre><code class="language-rust">fn fri_verify_final(
    stateConstant: FriVerificationStateConstant,
    stateVariable: FriVerificationStateVariable,
    last_layer_coefficients: Span&lt;felt252&gt;,
) -&gt; (FriVerificationStateConstant, FriVerificationStateVariable) {
    assert(stateVariable.iter == stateConstant.n_layers, 'Fri final called at wrong time');
    assert(
        hash_array(last_layer_coefficients) == stateConstant.last_layer_coefficients_hash,
        'Invalid last_layer_coefficients'
    );

    verify_last_layer(stateVariable.queries, last_layer_coefficients);

    (
        stateConstant,
        FriVerificationStateVariable { iter: stateVariable.iter + 1, queries: array![].span(), }
    )
}
</code></pre>



## Test Vectors

TKTK

## Security Considerations

* number of queries?
* size of domain?
* proof of work stuff?

security bits: `n_queries * log_n_cosets + proof_of_work_bits`
</section>
</section>
  </body>
</html>

