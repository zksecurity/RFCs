<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Starknet STARK Verifier</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>

    <!-- syntax highlighting -->
    <script class='remove'>
        async function loadRust() {
            //this is the function you call in 'preProcess', to load the highlighter
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
            const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
            const lang = "language-rust"; // this is the class you use to identify the language
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    const { action: responseAction, lang: responseLang } = data;
                    if (responseAction === action && responseLang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        async function loadPython() {
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/fd9652b0c0d64bfc9f8cae69c72030b1/raw/2315322f87ba81c92c22477a05da6c4181f02df2/respec-py.js"; // URL to Python highlighter
            const propName = "hljsDefinePython"; // Adjust this if needed
            const lang = "language-py";
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    if (data.action === action && data.lang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        var respecConfig = {
            preProcess: [loadRust, loadPython],
            specStatus: "unofficial",
            latestVersion: null,
            license: "cc0",
            editors: [
                {
                    name: "David Wong",
                    url: "https://www.zksecurity.xyz",
                },
            ],
            github: "zksecurity/RFCs",
            shortName: "starknet-stark",
        };
    </script>

</head>

<body>
    <section id="abstract">
        <p>In this document we specify the STARK verifier used in Starknet.</p>
    </section>
    <section id="sotd">
        <p>draft</p>
    </section>
    <section>
<h2>Overview</h2>
<aside class="warning">This specification is work-in-progress.</aside>

<p>In this section we give an overview of the STARK protocol.</p>
<aside class="note">Note that the protocol implemented closely resembles the high-level explanations of the <a href="https://eprint.iacr.org/2021/582">ethSTARK paper</a>, as such we refer to it in places.</aside>

<aside class="note">
This protocol is instantiated in several places to our knowledge:
<ul>
    <li><a href="https://github.com/starkware-libs/stone-prover/blob/main/src/starkware/main/cpu/cpu_air_verifier_main.cc">C++ implementation</a></li>
    <li><a href="https://zksecurity.github.io/stark-book/starkex/cairo.html">Solidity implementation</a></li>
    <li><a href="https://github.com/starkware-libs/cairo-lang/tree/9e6e0e96d208608d98635ccfad5b26285c4936e1/src/starkware/cairo/stark_verifier">Cairo0 implementation</a></li>
    <li><a href="https://github.com/HerodotusDev/integrity">Cairo1 implementation</a></li>
</ul>
</aside>

<p><img alt="STARK overview" src="/RFCs/img/starknet/stark_overview.png" /></p>
<section>
<h3>AIR Arithmetization</h3>
<p>TKTK</p>
</section>
<section>
<h3>Interactive Arithmetization</h3>
<p>TKTK</p>
</section>
<section>
<h3>STARK</h3>
<p>TKTK</p>
</section>
</section>
<section>
<h2>Constants</h2>
<p>TKTK</p>
</section>
<section>
<h2>Dependencies</h2>
<section>
<h3>Hash function</h3>
<ul>
<li>poseidon with hades permutation (https://docs.orochi.network/poseidon-hash/poseidon-permutation-design/hades-based-design.html ?)</li>
</ul>
</section>
<section>
<h3>Channel</h3>
<p>See the <a href="channel.html">Channel specification</a>.</p>
</section>
<section>
<h3>FRI</h3>
<p>See the <a href="fri.html">FRI specification</a>.</p>
<p>Specifically, we expose the following functions:</p>
<ul>
<li><code>fri_commit</code></li>
<li><code>fri_verify_initial</code></li>
<li><code>fri_verify_step</code></li>
<li><code>fri_verify_final</code></li>
</ul>
<p>as well as the two objects <code>FriVerificationStateConstant, FriVerificationStateVariable</code> defined in that specification.</p>
</section>
</section>
<section>
<h2>Configuration</h2>
<pre><code class="language-rust">struct StarkConfig {
    traces: TracesConfig,
    composition: TableCommitmentConfig,
    fri: FriConfig,
    proof_of_work: ProofOfWorkConfig,
    // Log2 of the trace domain size.
    log_trace_domain_size: felt252,
    // Number of queries to the last component, FRI.
    n_queries: felt252,
    // Log2 of the number of cosets composing the evaluation domain, where the coset size is the
    // trace length.
    log_n_cosets: felt252,
    // Number of layers that use a verifier friendly hash in each commitment.
    n_verifier_friendly_commitment_layers: felt252,
}
</code></pre>
<p>To validate:</p>
<ul>
<li>proof of work is validated as part of the FRI configuration validation</li>
<li>compute the log of the evaluation domain size as the log of the trace domain size plus the log of the number of cosets</li>
<li>if every coset is of size <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></msup></mrow></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></math> the <code>log_trace_domain_size</code>, and there is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>c</mi></msub></mrow></msup></mrow></math> cosets, then the evaluation domain size is expected to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>t</mi></msub><mo>&#x0002B;</mo><msub><mi>n</mi><mi>c</mi></msub></mrow></msup></mrow></math> (TODO: explain why we talk about cosets here)</li>
<li>traces.validate() (TODO)</li>
<li>composition.vector.validate()</li>
<li>the FRI configuration is validated as part of the FRI configuration validation</li>
</ul>
<pre><code class="language-rust">        self
            .composition
            .vector
            .validate(log_eval_domain_size, *self.n_verifier_friendly_commitment_layers);

        // Validate Fri config.
        self.fri.validate(*self.log_n_cosets, *self.n_verifier_friendly_commitment_layers);

        // Security bits.
        let n_queries: u32 = (*self.n_queries).try_into().unwrap();
        let log_n_cosets: u32 = (*self.log_n_cosets).try_into().unwrap();
        let proof_of_work_bits: u32 = (*self.proof_of_work.n_bits).try_into().unwrap();

        n_queries * log_n_cosets + proof_of_work_bits
    }
}
</code></pre>
</section>
<section>
<h2>Main STARK functions / Buiding blocks</h2>
<pre><code class="language-rust">struct StarkProof {
    config: StarkConfig,
    public_input: PublicInput,
    unsent_commitment: StarkUnsentCommitment,
    witness: StarkWitness,
}

struct StarkUnsentCommitment {
    traces: TracesUnsentCommitment,
    composition: felt252,
    // n_oods_values elements. The i-th value is the evaluation of the i-th mask item polynomial at
    // the OODS point, where the mask item polynomial is the interpolation polynomial of the
    // corresponding column shifted by the corresponding row_offset.
    oods_values: Span&lt;felt252&gt;,
    fri: FriUnsentCommitment,
    proof_of_work: ProofOfWorkUnsentCommitment,
}
</code></pre>
<section>
<h3>Trace and Evaluation Domains</h3>
<p>TODO: is this section useful?</p>
<p>There are three types of domains:</p>
<ol>
<li>The trace domain, this is the domain chosen to evaluate the execution trace polynomials. It is typically the smallest subgroup of order <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></msup></mrow></math> for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></math>, such that it can include all the constraints.</li>
<li>The evaluation domain, which is chosen as a subgroup of a power of two <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>e</mi></msub></mrow></msup></mrow></math> that encompasses the trace domain (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>e</mi><mo>&#x02265;</mo><mi>t</mi></mrow></math>). The "blown up factor" typically dictates how much larger the evaluation domain as a multiple.
(TODO: and then typically moved to a coset). (TODO: why n_cosets then? can this be seen as a union of cosets formed from the trace domain?)</li>
</ol>
<p>As such, the generator of the trace domain can be found as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mi>e</mi></msub><mo>&#x0003D;</mo><msup><mn>3</mn><mrow><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo>&#x02212;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0002F;</mo><msub><mi>n</mi><mi>t</mi></msub></mrow></msup></mrow></math> (since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mrow><mi>e</mi></mrow><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></msubsup><mo>&#x0003D;</mo><mn>1</mn></mrow></math>), and the generator of the evaluation domain can be found as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x003C9;</mi><mo>&#x0003D;</mo><msup><mn>3</mn><mrow><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo>&#x02212;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0002F;</mo><msub><mi>n</mi><mi>e</mi></msub></mrow></msup></mrow></math>.</p>
</section>
<section>
<h3>STARK commit</h3>
<p>The goal of the STARK commit is to process all of the commitments produced by the prover during the protocol (including the FRI commitments), as well as produce the verifier challenges:</p>
<ol>
<li>Absorb the original table with the channel.</li>
<li>Sample the interaction challenges (e.g. z and alpha for the memory check argument (different alpha called memory_alpha to distinguish it from the alpha used to aggregate the different constraints into the composition polynomial)).</li>
<li>Absorb the interaction table with the channel.</li>
<li>Sample the alpha challenge ("composition_alpha") to aggregate all the constraint quotient polynomials (caches the powers of alpha into "traces_coefficients").</li>
<li>Absorb the composition columns (the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow></math>) with the channel.</li>
<li>Sample the oods point (<code>interaction_after_composition</code>).</li>
<li>Absorb all evaluations with the channel.</li>
<li>Verify that the composition polynomial is correct by checking that its evaluation at the oods point is correct using some of the evaluations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mo>&#x02211;</mo><mi>j</mi></msub><msub><mi>C</mi><mi>j</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mi>&#x000D7;</mi><msup><mtext>oods_point</mtext><mi>i</mi></msup></mrow></math> (where the left hand side will need evaluations of the trace polynomials (called maks values) and the right hand side will need evaluations of the composition column polynomials, everything is in that oods vector)</li>
<li>Sample the oods_alpha challenge with the channel.</li>
<li>Call <code>fri_commit</code></li>
</ol>
</section>
<section>
<h3>STARK verify</h3>
<p>The goal of STARK verify is to verify evaluation queries (by checking that evaluations exist in the committed polynomials) and the FRI queries (by running the FRI verification).</p>
<p>To do this, we simply call the <code>fri_verify_initial</code> function contained in the FRI specification, and giving it the following oracle:</p>
<p>The oracle should provide the evaluations, under the same set of FRI queries (and specifically the point they are requesting the evaluations at) of the following polynomials:</p>
<ul>
<li>the traces polynomials, which include both the original trace polynomial and the interaction trace polynomial)</li>
<li>the composition column polynomials</li>
</ul>
<p>In addition the oracle should verify decommitment proofs (Merkle membership proofs) for each of these evaluations. We refer to the <a href="merkle.html">Merkle Tree Polynomial Commitments specification</a> on how to verify evaluation proofs.</p>
<aside class="warning">The logic of the oracle must be implemented as part of the verification. The term "oracle" simply refers to an opaque callback function from the FRI protocol's perspective.</aside>

</section>
</section>
<section>
<h2>Full Protocol</h2>
<p>The protocol is split into 3 core functions:</p>
<ul>
<li><code>verify_initial</code> as defined below.</li>
<li><code>verify_step</code> is a wrapper around <code>fri_verify_step</code> (see the <a href="#fri">FRI</a> section).</li>
<li><code>verify_final</code> is a wrapper around <code>fri_verify_final</code> (see the <a href="#fri">FRI</a> section).</li>
</ul>
<p>One can successively call them in the following order to verify a proof:</p>
<ol>
<li>Call <code>verify_initial</code> on the proof and return:</li>
<li>the <code>FriVerificationStateConstant</code> object</li>
<li>the <code>FriVerificationStateVariable</code> object</li>
<li>the <code>last_layer_coefficients</code></li>
<li>the security bits &lt;-- TODO: remove this?</li>
<li>Call verify_step in a loop on each layer of the proof (<code>n_layers</code> of them according to the StateConstant returned) and pass the FriVerificationStateVariable in between each calls</li>
<li>Call verify_final on the StateConstant and StateVariable objects</li>
<li>Enforce that the the StateVariable's iter field is <code>n_layers + 1</code></li>
<li>Return the security bits. (TODO: do we need this)</li>
</ol>
<p>The verify initial function is defined as:</p>
<ol>
<li>Validate the configuration and return the security_bits (TODO: how is security bits calculated).</li>
<li>Produce a stark domain object based on the configuration log_trace_domain_size and log_n_coset (TODO:).</li>
<li>Validate the public input (TODO: specify an external function for that?).</li>
<li>Compute the initial digest as <code>get_public_input_hash(public_input, cfg.n_verifier_friendly_commitment_layers, settings)</code> (TODO: define external function for that).</li>
<li>Initialize the channel using the digest as defined in the <a href="#channel">Channel</a> section.</li>
<li>Call STARK commit as defined in the <a href="#stark-commit">STARK commit</a> section.</li>
<li>Call STARK verify as defined in the <a href="#stark-verify">STARK verify</a> section.</li>
</ol>
</section>
</body>

</html>