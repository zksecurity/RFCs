<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Starknet STARK Verifier</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>

    <!-- syntax highlighting -->
    <script class='remove'>
        async function loadRust() {
            //this is the function you call in 'preProcess', to load the highlighter
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
            const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
            const lang = "language-rust"; // this is the class you use to identify the language
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    const { action: responseAction, lang: responseLang } = data;
                    if (responseAction === action && responseLang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        async function loadPython() {
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/fd9652b0c0d64bfc9f8cae69c72030b1/raw/2315322f87ba81c92c22477a05da6c4181f02df2/respec-py.js"; // URL to Python highlighter
            const propName = "hljsDefinePython"; // Adjust this if needed
            const lang = "language-py";
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    if (data.action === action && data.lang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        var respecConfig = {
            preProcess: [loadRust, loadPython],
            specStatus: "unofficial",
            latestVersion: null,
            license: "cc0",
            editors: [
                {
                    name: "David Wong",
                    url: "https://www.zksecurity.xyz",
                },
            ],
            github: "zksecurity/RFCs",
            shortName: "starknet-stark",
        };
    </script>

</head>

<body>
    <section id="abstract">
        <p>In this document we specify the STARK verifier used in Starknet.</p>
    </section>
    <section id="sotd">
        <p>draft</p>
    </section>
    <section>
<h2>Overview</h2>
<aside class="warning">This specification is work-in-progress.</aside>

<aside class="warning">The protocol specified here is not "zero-knowledge". It is purely aimed at providing succinctness. That is, it is useful to delegate computation.</aside>

<aside class="note">Note that the protocol implemented closely resembles the high-level explanations of the <a href="https://eprint.iacr.org/2021/582">ethSTARK paper</a>, as such we refer to it in places.</aside>

<aside class="note">
This protocol is instantiated in several places to our knowledge:
<ul>
    <li><a href="https://github.com/starkware-libs/stone-prover/blob/main/src/starkware/main/cpu/cpu_air_verifier_main.cc">C++ implementation</a></li>
    <li><a href="https://zksecurity.github.io/stark-book/starkex/cairo.html">Solidity implementation</a></li>
    <li><a href="https://github.com/starkware-libs/cairo-lang/tree/9e6e0e96d208608d98635ccfad5b26285c4936e1/src/starkware/cairo/stark_verifier">Cairo0 implementation</a></li>
    <li><a href="https://github.com/HerodotusDev/integrity">Cairo1 implementation</a></li>
</ul>
</aside>

<p>In this section we give a brief overview of the Starknet STARK protocol.
While the protocol used is designed to verify Cairo programs, we provide an agnostic specification.
The instantiation of this protocol with Cairo should be the object of a different specification.</p>
<p>Before we delve into the details, let's look at the protocol from a high-level protocol diagram point of view. The Starknet STARK protocol is divided in three main phases:</p>
<ol>
<li>Construction of an interactive arithmetization. In this phase the prover commits to different parts of the execution trace it wants to prove, using random challenges in-between.</li>
<li>Aggregation of constraints into a composition polynomial. In this phase the prover commits to a composition polynomial that, if checked by FRI, proves that the execution trace satisfies the constraints. It also produces evaluations of commitments at a random point so that the verifier can check that the composition polynomial is well-formed.</li>
<li>Aggregation of FRI proofs and FRI protocol. The composition polynomial FRI check as well as evaluation proofs (using FRI-PCS) of all the sent evaluations are aggregated into a single FRI check. The FRI protocol is then run to verify the aggregated FRI proof. See the <a href="fri.html">Starknet FRI Verifier specification</a> for more details.</li>
</ol>
<p>We illustrate the flow in the following diagram:</p>
<p><img alt="STARK overview" src="/RFCs/img/starknet/stark_overview.png" /></p>
<p>In the next sections we review the different phases.</p>
<section>
<h3>Interactive AIR Arithmetization</h3>
<p>But first, we quickly remind the reader that the Starknet STARK protocol allows a prover to convince a verifier that an AIR (Algebraic Intermediate Representation) arithmetization is satisfied by their witness. This is generally augmented to also include a public input, usually via a <a href="https://zksecurity.github.io/stark-book/cairo/memory.html">public memory</a> extension.</p>
<p>AIR is essentially two things:</p>
<ol>
<li>an indexed table representing the execution trace of a run, where columns can be seen as registers and the rows the values they take as one steps through a program. The table takes values when a prover tries to prove an execution. </li>
<li>a list of fixed constraints that are agreed on. </li>
</ol>
<p>The indexing of the table is chosen as the elements of the smallest subgroup of power <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>2</mn></mrow></math> that can index the table.</p>
<p>Furthermore, the columns of a table can be grouped, which allows the prover to fill the table group by group, using challenges from the verifier in-between. This is useful in order to perform an interactive arithmetization where parts of the encoded circuit need verifier randomness to be computed.</p>
<p>We give the example of two "original" columns and one "interaction" column, indexed using the multiplicative subgroup of the 16-th roots of unity:</p>
<p><img alt="air" src="/RFCs/img/starknet/air.png" /></p>
<aside class="example">Here one constraint could be to enforce that `col0[i] + col1[i] - col0[i+1] = 0` on every row `i` except the last one.

As the columns of the table are later interpolated over the index domain, such constraints are usually described and applied as polynomials. So the previous example constraint would look like the following polynomial:

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfrac><mrow><msub><mtext>col</mtext><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mtext>col</mtext><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mtext>col</mtext><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mi>&#x000B7;</mi><mi>w</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><msub><mi>D</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></mfrac></mrow></math>

where the domain polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow></math> can be efficiently computed as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mfrac><mrow><msup><mi>x</mi><mrow><mn>16</mn></mrow></msup><mo>&#x02212;</mo><mn>1</mn></mrow><mrow><msup><mi>w</mi><mrow><mn>15</mn></mrow></msup><mo>&#x02212;</mo><mn>1</mn></mrow></mfrac></mrow></math>.</aside>

<p>The first phase of the Starknet STARK protocol is to iteratively construct the trace tables (what we previously called interactive arithmetization). The prover sends commitments to parts of the table, and receives verifier challenges in between.</p>
<aside class="note">In the instantiation of the Starknet STARK protocol, there are only two execution trace tables: the original trace table and the interaction trace table, the verifier challenges received in between are called the interaction challenges. Different Cairo layouts will give place to different trace tables and interaction challenges.</aside>

<ul>
<li>TODO: we should make this part agnostic to Cairo though.</li>
</ul>
</section>
<section>
<h3>Composition Polynomial</h3>
<p>The role of the verifier is now to verify constraints of the form of polynomials on the trace column polynomials, applied on a domain (a list of all the indexes on which the constraint applies).</p>
<p>As with our example above, we can imagine a list of constraints <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> that need to vanish on a list of associated domains described by their domain polynomials <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<p>By definition, this can be reduced to checking that you can write each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mi>&#x000B7;</mi><mi>q</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> for some quotient polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>q</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mo stretchy="false">&#x00028;</mo><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><mi>d</mi><mi>e</mi><mi>g</mi><mo stretchy="false">&#x00028;</mo><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<p>While protocols based on polynomial commitments like KZG would commit to the quotient polynomial and then prove the relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mi>&#x000B7;</mi><mi>q</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> at a random point (using Schwartz-Zippel), the Starknet STARK protocol uses a different approach: it uses a FRI check to prove that the commitment to the evaluations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>q</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></mfrac></mrow></math> correctly represents a polynomial of low degree.</p>
<p>As such, the role of the verifier is to verify that all the quotient polynomials associated with all the constraints exist and are of low-degree.</p>
<p>TODO: define low-degree better</p>
<p>As we want to avoid having to go through many FRI checks, the verifier sends a challenge <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x003B1;</mi></mrow></math> which the prover can use to aggregate all of the constraint quotient polynomials into a <strong>composition polynomial</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mi>:</mi><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mrow><mi>i</mi><mo>&#x0003D;</mo><mn>0</mn></mrow></msub><mfrac><mrow><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mi>&#x000B7;</mi><msup><mi>&#x003B1;</mi><mi>i</mi></msup></mrow></mfrac></mrow></math>.</p>
<p>This composition polynomial is quite big, so the prover provides a commitment to chunks or columns of the composition polynomials, interpreting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi></mrow></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><msup><mi>x</mi><mi>i</mi></msup></mrow></math>.</p>
<aside class="note">In the instantiation of this specification with Cairo, there are only two composition column polynomials: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mi>&#x000B7;</mi><mi>x</mi></mrow></math>.</aside>

<p>Finally, to allow the verifier to check that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi></mrow></math> has correctly been committed, Schwartz-Zippel is used with a random verifier challenge called the "oods point". Specifically, the verifier evaluates the following and check that they match:</p>
<ul>
<li>the left-hand side <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mo>&#x02211;</mo><mrow><mi>i</mi><mo>&#x0003D;</mo><mn>0</mn></mrow></msub><mfrac><mrow><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo></mrow><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo></mrow></mfrac><mi>&#x000B7;</mi><msup><mi>&#x003B1;</mi><mi>i</mi></msup></mrow></math> </li>
<li>the right-hand side <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mi>&#x000B7;</mi><mtext>oods_point</mtext></mrow></math></li>
</ul>
<p>Of course, the verifier cannot evaluate both sides without the help of the prover! The left-hand side involves evaluations of the trace polynomials at the oods point (and potentially shifted oods points), and the right-hand side involves evaluations of the composition column polynomials at the oods point as well.</p>
<p>As such, the prover sends the needed evaluations to the verifier so that the verifier can perform the check. (These evaluations are often referred to as the "mask" values.)</p>
<aside class="example">
With our previous example constraint, the prover would have to provide the evaluations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>f</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mo>&#x0002C;</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mo>&#x0002C;</mo><msub><mi>f</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mi>&#x000B7;</mi><mi>w</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002C;</mo><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mo>&#x0002C;</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo></mrow></math>.
</aside>

<p>Notice that this "oods check" cannot happen in the domain used to index the trace polynomials. This is because the left-hand side involves divisions by domain polynomials <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo></mrow></math>, which might lead to divisions by zero. </p>
<aside class="example">If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mtext>oods_point</mtext><mo>&#x0003D;</mo><msup><mi>w</mi><mn>3</mn></msup></mrow></math> and the second constraint is associated to the whole 16-element domain, then the verifier would have to compute a division with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x00028;</mo><msup><mi>w</mi><mn>3</mn></msup><msup><mo stretchy="false">&#x00029;</mo><mrow><mn>16</mn></mrow></msup><mo>&#x02212;</mo><mn>1</mn></mrow></math> which would be a division by zero.</aside>

<p>This is why the oods point is called "out-of-domain sampling". Although nothing special is done when sampling this point, but the probability that it ends up in the trace domain is very low.</p>
<p>TODO: explain what parts does the term "DEEP" refer to in this protocol.</p>
</section>
<section>
<h3>Aggregation and FRI Proof</h3>
<p>The verifier now has to:</p>
<ol>
<li>Perform a FRI check on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mi>x</mi><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> (which will verify the original prover claim that the trace polynomials satistify the constraints).</li>
<li>Verify all the evaluations that were sent, the prover and the verifier can use FRI-PCS for that, as described in <a href="fri.html#fri-pcs">the FRI-PCS section of the Starknet FRI Verifier specification</a>.</li>
</ol>
<p>TODO: the second point also should have the effect of proving that the commitments to the trace column polynomials are correct (as they will also act as FRI checks)</p>
<p>In order to avoid running multiple instances of the FRI protocol, the FRI Aggregation technique is used as described in <a href="fri.html#aggregating-multiple-fri-proofs">the Aggregating Multiple FRI Proofs section of the Starknet FRI Verifier specification</a>. The verifier sends a challenge called <code>oods_alpha</code> which is used to aggregate all of the first layer of the previously discussed FRI proofs.</p>
<p>Finally, the FRI protocol is run as described in <a href="fri.html">the Starknet FRI Verifier specification</a>.</p>
</section>
</section>
<section>
<h2>Dependencies</h2>
<p>In this section we list all of the dependencies and interfaces this standard relies on.</p>
<section>
<h3>AIR Arithmetization Dependency</h3>
<p>While this specification was written with Cairo in mind, it should be instantiatiable with any AIR arithmetization that can be verified using the STARK protocol.</p>
<p>A protocol that wants to use this specification should provide the following:</p>
<p><strong>interactive arithmetization</strong>. A description of the interactive arithmetization step, which should include in what order the different tables are committed and what verifier challenges are sent in-between.</p>
<p><strong><code>eval_composition_polynomial</code></strong>. A function that takes all of the commitments, all of the evaluations, and a number of Merkle tree witnesses sent by the prover and produces an evaluation of the composition polynomial at the oods point. (This evaluation will depend heavily on the number of trace columns and the constraints of the given AIR arithmetization.) The function is expected to verify any decommitment (via the Merkle tree witnesses) that it uses.</p>
<p><strong><code>eval_oods_polynomial</code></strong>. A function that takes all of the commitments, all of the evaluations, and a number of Merkle tree witnesses sent by the prover and produces a list of evaluations of the first layer polynomial of the FRI check at a list of queried points. The function is expected to verify any decommitment (via the Merkle tree witnesses) that it uses.</p>
<p>We refer to the <a href="merkle.html">Merkle Tree Polynomial Commitments specification</a> on how to verify decommitments.</p>
</section>
</section>
<section>
<h2>Constants</h2>
<p>We use the following constants throughout the protocol.</p>
<section>
<h3>Protocol constants</h3>
<p><strong><code>STARKNET_PRIME = 3618502788666131213697322783095070105623107215331596699973092056135872020481</code></strong>. The Starknet prime (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><mn>251</mn></mrow></msup><mo>&#x0002B;</mo><mn>17</mn><mi>&#x000B7;</mi><msup><mn>2</mn><mrow><mn>192</mn></mrow></msup><mo>&#x0002B;</mo><mn>1</mn></mrow></math>).</p>
<p><strong><code>FIELD_GENERATOR = 3</code></strong>. The generator for the main multiplicative subgroup of the Starknet field. This is also used as coset factor to produce the coset used in the first layer's evaluation.</p>
</section>
<section>
<h3>Channel</h3>
<p>See the <a href="channel.html">Channel specification</a> for more details.</p>
</section>
<section>
<h3>FRI</h3>
<p>See the <a href="fri.html">Starknet FRI Verifier specification</a>.</p>
<p>Specifically, we expose the following functions:</p>
<ul>
<li><code>fri_commit</code></li>
<li><code>fri_verify_initial</code></li>
<li><code>fri_verify_step</code></li>
<li><code>fri_verify_final</code></li>
</ul>
<p>as well as the two objects <code>FriVerificationStateConstant</code>, <code>FriVerificationStateVariable</code> defined in that specification.</p>
</section>
</section>
<section>
<h2>Configuration</h2>
<pre><code class="language-rust">struct StarkConfig {
    traces: TracesConfig,
    composition: TableCommitmentConfig,
    fri: FriConfig,
    proof_of_work: ProofOfWorkConfig,
    // Log2 of the trace domain size.
    log_trace_domain_size: felt252,
    // Number of queries to the last component, FRI.
    n_queries: felt252,
    // Log2 of the number of cosets composing the evaluation domain, where the coset size is the
    // trace length.
    log_n_cosets: felt252,
    // Number of layers that use a verifier friendly hash in each commitment.
    n_verifier_friendly_commitment_layers: felt252,
}
</code></pre>
<p>To validate:</p>
<ul>
<li>compute the log of the evaluation domain size as the log of the trace domain size plus the log of the number of cosets</li>
<li>if every coset is of size <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></msup></mrow></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></math> the <code>log_trace_domain_size</code>, and there is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>c</mi></msub></mrow></msup></mrow></math> cosets, then the evaluation domain size is expected to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>t</mi></msub><mo>&#x0002B;</mo><msub><mi>n</mi><mi>c</mi></msub></mrow></msup></mrow></math> (TODO: explain why we talk about cosets here)</li>
<li>traces.validate() (TODO)</li>
<li>composition.vector.validate() (TODO)</li>
<li>the rest (proof of work, FRI configuration) is validated as part of the FRI configuration validation</li>
</ul>
</section>
<section>
<h2>Buiding Blocks</h2>
<p>The verifier accepts the following proof as argument:</p>
<pre><code class="language-rust">struct StarkProof {
    config: StarkConfig,
    public_input: PublicInput,
    unsent_commitment: StarkUnsentCommitment,
    witness: StarkWitness,
}

struct StarkUnsentCommitment {
    traces: TracesUnsentCommitment,
    composition: felt252,
    // n_oods_values elements. The i-th value is the evaluation of the i-th mask item polynomial at
    // the OODS point, where the mask item polynomial is the interpolation polynomial of the
    // corresponding column shifted by the corresponding row_offset.
    oods_values: Span&lt;felt252&gt;,
    fri: FriUnsentCommitment,
    proof_of_work: ProofOfWorkUnsentCommitment,
}
</code></pre>
<p>We assume that the public input is instantiated and verified by the parent protocol, and thus is out of scope of this standard.</p>
<section>
<h3>Trace and Evaluation Domains</h3>
<p>There are three types of domains:</p>
<ol>
<li>The trace domain, this is the domain chosen to evaluate the execution trace polynomials. It is typically the smallest subgroup of order <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></msup></mrow></math> for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></math>, such that it can include all the constraints.</li>
<li>The evaluation domain, which is chosen as a subgroup of a power of two <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><msub><mi>n</mi><mi>e</mi></msub></mrow></msup></mrow></math> that encompasses the trace domain (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>e</mi><mo>&#x02265;</mo><mi>t</mi></mrow></math>). The "blown up factor" typically dictates how much larger the evaluation domain as a multiple.
(TODO: and then typically moved to a coset). (TODO: why n_cosets then? can this be seen as a union of cosets formed from the trace domain?)</li>
</ol>
<p>As such, the generator of the trace domain can be found as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>&#x003C9;</mi><mi>e</mi></msub><mo>&#x0003D;</mo><msup><mn>3</mn><mrow><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo>&#x02212;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0002F;</mo><msub><mi>n</mi><mi>t</mi></msub></mrow></msup></mrow></math> (since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>&#x003C9;</mi><mrow><mi>e</mi></mrow><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow></msubsup><mo>&#x0003D;</mo><mn>1</mn></mrow></math>), and the generator of the evaluation domain can be found as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x003C9;</mi><mo>&#x0003D;</mo><msup><mn>3</mn><mrow><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo>&#x02212;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0002F;</mo><msub><mi>n</mi><mi>e</mi></msub></mrow></msup></mrow></math>.</p>
<aside class="note">The reason for choosing a coset is two-folds. First, in ZK protocols you want to avoid decommitting actual witness values by querying points in the trace domain. Choosing another domain helps but is not sufficient. As this specification does not provide a ZK protocol. The second reason is the one that is interesting to us: it is an optimization reason. As the prover needs to compute the composition polynomial, they can do this in the monomial basis (using vectors of coefficient of the polynomials) but it is expensive. For this reason, they usually operate on polynomials using the lagrange basis (using vectors of evaluations of the polynomials). As such, calculating the composition polynomial leads to divisions by zero if the trace domain is used. The prover could in theory use any other domains, but they decide to use the same domain that they use to commit (the evaluation domain) to avoid having to interpolate and re-evaluate in the domain to commit (which would involve two FFTs).</aside>

</section>
<section>
<h3>Commitments</h3>
<p>Commitments to all the polynomials, before the FRI protocol, are done on evaluations of polynomials in the evaluation domain (as defined in the previous subsection).</p>
<p>Commitments to all the polynomials, before the FRI protocol, are done using table commitments as described in the <a href="merkle.html#table-commitments">Table Commitments section of the Merkle Tree Polynomial Commitments specification</a>.</p>
<ul>
<li>For trace polynomials in the interactive arithmetization phase, the tables committed into the leaves represent the evaluations of each of the trace columns at the same point.</li>
<li>For composition column polynomials in the composition polynomial phase, the tables committed into the leaves represent the evaluations of each of the composition columns at the same point.</li>
</ul>
</section>
<section>
<h3>STARK commit</h3>
<p>The goal of the STARK commit is to process all of the commitments produced by the prover during the protocol (including the FRI commitments), as well as produce the verifier challenges.</p>
<ol>
<li><strong>Interactive arithmetization to absorb the execution trace tables</strong>:<ol>
<li>Absorb the original table with the channel.</li>
<li>Sample the interaction challenges (e.g. z and alpha for the memory check argument (different alpha called memory_alpha to distinguish it from the alpha used to aggregate the different constraints into the composition polynomial)).</li>
<li>Absorb the interaction table with the channel.</li>
</ol>
</li>
<li><strong>Produce the aggregation of the constraint quotient polynomials as the composition polynomial</strong>:<ol>
<li>Sample the alpha challenge ("composition_alpha") to aggregate all the constraint quotient polynomials (caches the powers of alpha into "traces_coefficients").</li>
<li>Absorb the composition columns (the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow></math>) with the channel.</li>
<li>Sample the oods point (<code>interaction_after_composition</code>).</li>
<li>Absorb all evaluations with the channel.</li>
<li>Verify that the composition polynomial is correct by checking that its evaluation at the oods point is correct using some of the evaluations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mo>&#x02211;</mo><mi>j</mi></msub><mfrac><mrow><msub><mi>C</mi><mi>j</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo></mrow><mrow><msub><mi>D</mi><mi>j</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>odds_point</mtext><mo stretchy="false">&#x00029;</mo></mrow></mfrac><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">&#x00028;</mo><mtext>oods_point</mtext><mo stretchy="false">&#x00029;</mo><mi>&#x000D7;</mi><msup><mtext>oods_point</mtext><mi>i</mi></msup></mrow></math>.<ol>
<li>The right-hand side can be computed directly using the evaluations sent by the prover</li>
<li>The left-hand side has to be computed using the <code>eval_composition_polynomial</code> function defined in the <a href="#air-arithmetization-dependency">AIR Arithmetization Dependency section</a>.</li>
</ol>
</li>
</ol>
</li>
<li><strong>Produce a challenge to aggregate all FRI checks and run the FRI protocol</strong>:<ol>
<li>Sample the oods_alpha challenge with the channel.</li>
<li>Call <code>fri_commit</code>.</li>
</ol>
</li>
</ol>
</section>
<section>
<h3>STARK verify</h3>
<p>The goal of STARK verify is to verify evaluation queries (by checking that evaluations exist in the committed polynomials) and the FRI queries (by running the FRI verification).</p>
<p>To do this, we simply call the <code>fri_verify_initial</code> function contained in the FRI specification and give it the values computed by <code>eval_oods_polynomial</code> (as defined in the <a href="#air-arithmetization-dependency">AIR Arithmetization Dependency section</a>) as first evaluations associated with the queried points. It should return two FRI objects.</p>
<aside class="note">These evaluations will only provide evaluations of the first layer polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow></math> at query points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow></math>. The prover will witness evaluations at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><msub><mi>v</mi><mi>i</mi></msub></mrow></math> by themselves and prove that they are present in the first FRI commitment (of the polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow></math>.</aside>

</section>
</section>
<section>
<h2>Full Protocol</h2>
<p>The protocol is split into 3 core functions:</p>
<ul>
<li><code>verify_initial</code> as defined below.</li>
<li><code>verify_step</code> is a wrapper around <code>fri_verify_step</code> (see the <a href="#fri">FRI</a> section).</li>
<li><code>verify_final</code> is a wrapper around <code>fri_verify_final</code> (see the <a href="#fri">FRI</a> section).</li>
</ul>
<p>The verify initial function is defined as:</p>
<ol>
<li>Validate the configuration and return the security_bits (TODO: how is security bits calculated).</li>
<li>Produce a stark domain object based on the configuration log_trace_domain_size and log_n_coset (TODO:).</li>
<li>Validate the public input (TODO: specify an external function for that?).</li>
<li>Compute the initial digest as <code>get_public_input_hash(public_input, cfg.n_verifier_friendly_commitment_layers, settings)</code> (TODO: define external function for that).</li>
<li>Initialize the channel using the digest as defined in the <a href="#channel">Channel</a> section.</li>
<li>Call STARK commit as defined in the <a href="#stark-commit">STARK commit</a> section.</li>
<li>Call STARK verify as defined in the <a href="#stark-verify">STARK verify</a> section and return the two FRI objects to the caller.</li>
</ol>
<p>One can successively call them in the following order to verify a proof:</p>
<ol>
<li>Call <code>verify_initial</code> on the proof and return:<ul>
<li>the <code>FriVerificationStateConstant</code> object</li>
<li>the <code>FriVerificationStateVariable</code> object</li>
<li>the <code>last_layer_coefficients</code></li>
<li>the security bits &lt;-- TODO: remove this?</li>
</ul>
</li>
<li>Call verify_step in a loop on each layer of the proof (<code>n_layers</code> of them according to the StateConstant returned) and pass the FriVerificationStateVariable in between each calls</li>
<li>Call verify_final on the StateConstant and StateVariable objects</li>
<li>Enforce that the the StateVariable's iter field is <code>n_layers + 1</code></li>
<li>Return the security bits. (TODO: do we need this)</li>
</ol>
</section>
</body>

</html>