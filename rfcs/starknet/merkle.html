<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Starknet Merkle Tree Polynomial Commitments</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>

    <!-- syntax highlighting -->
    <script class='remove'>
        async function loadRust() {
            //this is the function you call in 'preProcess', to load the highlighter
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
            const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
            const lang = "language-rust"; // this is the class you use to identify the language
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    const { action: responseAction, lang: responseLang } = data;
                    if (responseAction === action && responseLang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        async function loadPython() {
            const worker = await new Promise(resolve => {
                require(["core/worker"], ({ worker }) => resolve(worker));
            });
            const action = "highlight-load-lang";
            const langURL =
                "https://gistcdn.githack.com/mimoo/fd9652b0c0d64bfc9f8cae69c72030b1/raw/2315322f87ba81c92c22477a05da6c4181f02df2/respec-py.js"; // URL to Python highlighter
            const propName = "hljsDefinePython"; // Adjust this if needed
            const lang = "language-py";
            worker.postMessage({ action, langURL, propName, lang });
            return new Promise(resolve => {
                worker.addEventListener("message", function listener({ data }) {
                    if (data.action === action && data.lang === lang) {
                        worker.removeEventListener("message", listener);
                        resolve();
                    }
                });
            });
        }

        var respecConfig = {
            preProcess: [loadRust, loadPython],
            specStatus: "unofficial",
            latestVersion: null,
            license: "cc0",
            editors: [
                {
                    name: "David Wong",
                    url: "https://www.zksecurity.xyz",
                },
            ],
            github: "zksecurity/RFCs",
            shortName: "starknet-commit",
        };
    </script>

</head>

<body>
    <section id="abstract">
        <p>Merkle tree polynomial commitments provide a standard on how to commit to a polynomial using a Merkle tree.</p>
    </section>
    <section id="sotd">
        <p>draft</p>
    </section>
    <section>
<h2>Overview</h2>
<aside class="warning">This specification is work-in-progress.</aside>

<p>Commitments of polynomials are done using <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle trees</a>. The Merkle trees can be configured to hash some parameterized number of the lower layers using a circuit-friendly hash function (Poseidon).</p>
</section>
<section>
<h2>Dependencies</h2>
<ul>
<li>the verifier-friendly hash is <code>hades_permutation(s1, s2, 2)</code> always setting the last field element to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>2</mn></mrow></math></li>
<li>the default hash is either keccak256 or blake2s</li>
</ul>
</section>
<section>
<h2>Constants</h2>
<p><strong><code>MONTGOMERY_R = 3618502788666127798953978732740734578953660990361066340291730267701097005025</code></strong>. The Montgomery form of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup><mspace width="1em" /><mi>mod</mi><mspace width="0.333em" /><mtext>STARK_PRIME</mtext></mrow></math>.</p>
</section>
<section>
<h2>Vector Commitments</h2>
<p>A vector commitment is simply a Merkle tree. It is configured with two fields:</p>
<ul>
<li><code>height</code>: the height of the Merkle tree</li>
<li><code>n_verifier_friendly_commitment_layers</code>: the depth at which layers will start using the verifier-friendly hash.</li>
</ul>
<p><img src="/RFCs/img/starknet/tree_indexing.png" style="max-width:100%">
<img src="/RFCs/img/starknet/vector_commit.png" style="max-width:100%"></p>
</section>
<section>
<h2>Table Commitments</h2>
<p>A table commitment in this context is a vector commitment where leaves are hashes of multiple values. Or in other words, a leaf can be seen as a hash of a table of multiple columns and a single row.</p>
<p>It can be configured with two fields:</p>
<ul>
<li><code>n_columns</code>: the number of columns in each leaf of the tree</li>
<li><code>vector</code>: the vector commitment configuration (see previous section).</li>
</ul>
<p>A few examples:</p>
<ul>
<li>the trace polynomials in the <a href="stark.html">STARK verifier specification</a> are table commitments where each leaf is a hash of the evaluations of all the trace column polynomials at the same point</li>
<li>the composition polynomial in the <a href="stark.html">STARK verifier specification</a> is a table commitment where each leaf is a hash of the evaluations of the composition polynomial columns at the same point</li>
<li>the FRI layer commitments in the <a href="fri.html">FRI verifier specification</a> are table commitments where each leaf is a hash of the evaluations of the FRI layer columns at associated points (e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><mi>v</mi></mrow></math>)</li>
</ul>
<p>Note that values are multiplied to the <code>MONTGOMERY_R</code> constant before being hashed as leaves in the tree. </p>
<p>TODO: explain why montgomery</p>
</section>
<section>
<h2>Index to Path Conversion</h2>
<p>Random evaluation of the polynomial might produce an index in the range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>&#x0002C;</mo><msup><mn>2</mn><mi>h</mi></msup><mo stretchy="false">&#x00029;</mo></mrow></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi></mrow></math> the height of the tree. Due to the way the tree is indexed, we have to convert that index into a path. To do that, the index is added with the value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow></math> to set its MSB.</p>
<p>For example, the index <code>0</code> becomes the path <code>10000</code> which correctly points to the first leaf in our example.</p>
</section>
<section>
<h2>Vector Membership Proofs</h2>
<p>A vector decommitment/membership proof must provide a witness (the neighbor nodes missing to compute the root of the Merkle tree) ordered in a specific way. The following algorithm dictates in which order the nodes hash values provided in the proof are consumed:</p>
<p><img src="/RFCs/img/starknet/vector_decommit.png" style="max-width:100%"></p>
</section>
<section>
<h2>Verifier-Friendly Layers</h2>
<p>A <code>n_verifier_friendly_layers</code> variable can be passed which dictates at which layer the Merkle tree starts using a verifier-friendly hash.</p>
<p>In the following example, the height of the table commitment is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>6</mn></mrow></math> (and the height of the vector commitment is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>5</mn></mrow></math>). As such, a <code>n_verifier_friendly_layers</code> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>6</mn></mrow></math> would mean that only the table would use the verifier-friendly hash. A <code>n_verifier_friendly_layers</code> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>5</mn></mrow></math> would mean that the last / bottom layer of the Merkle tree would also use the verifier-friendly hash. A <code>n_verifier_friendly_layers</code> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn></mrow></math> would mean that all layers would use the verifier-friendly hash.</p>
<p><img src="/RFCs/img/starknet/tree_height.png" style="max-width:100%"></p>
<section>
<h3>Note on commitment multiple evaluations under the same leaf</h3>
<p>As can be seen in the previous diagram, a leaf can contain (using the technique in <a href="#table-commitments">table commitments</a>) multiple evaluations of the same polynomial at different points. This is useful for the FRI layer commitments where the same polynomial is evaluated at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02212;</mo><mi>v</mi></mrow></math> (and potentially more values depending on skipped layers).</p>
</section>
</section>
</body>

</html>